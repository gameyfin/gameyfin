package org.gameyfin.plugins.download.torrent

import com.sun.net.httpserver.HttpServer
import org.libtorrent4j.TorrentInfo
import org.slf4j.LoggerFactory
import java.io.OutputStream
import java.net.InetSocketAddress
import java.net.URLDecoder
import java.nio.charset.StandardCharsets
import java.nio.file.Path
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.ExecutorService

/**
 * A simple HTTP BitTorrent tracker implementation using libtorrent4j.
 * This tracker runs embedded within the application and tracks torrents generated by the plugin.
 */
class LibtorrentTracker(
    private val port: Int,
    private val externalHost: String
) {
    private val log = LoggerFactory.getLogger(LibtorrentTracker::class.java)
    private lateinit var server: HttpServer
    private lateinit var executor: ExecutorService
    private val torrents = ConcurrentHashMap<String, TorrentTrackerInfo>()
    
    data class TorrentTrackerInfo(
        val infoHash: String,
        val peers: MutableSet<PeerInfo> = ConcurrentHashMap.newKeySet()
    )
    
    data class PeerInfo(
        val peerId: String,
        val ip: String,
        val port: Int,
        val uploaded: Long = 0,
        val downloaded: Long = 0,
        val left: Long = 0
    )
    
    fun start() {
        server = HttpServer.create(InetSocketAddress(port), 0)
        executor = java.util.concurrent.Executors.newCachedThreadPool()
        server.executor = executor
        
        server.createContext("/announce") { exchange ->
            try {
                val query = exchange.requestURI.query ?: ""
                val params = parseQueryString(query)
                
                val infoHash = params["info_hash"] ?: run {
                    sendErrorResponse(exchange, "Missing info_hash")
                    return@createContext
                }
                
                val peerId = params["peer_id"] ?: run {
                    sendErrorResponse(exchange, "Missing peer_id")
                    return@createContext
                }
                
                val port = params["port"]?.toIntOrNull() ?: run {
                    sendErrorResponse(exchange, "Missing or invalid port")
                    return@createContext
                }
                
                val ip = params["ip"] ?: exchange.remoteAddress.address.hostAddress
                val uploaded = params["uploaded"]?.toLongOrNull() ?: 0
                val downloaded = params["downloaded"]?.toLongOrNull() ?: 0
                val left = params["left"]?.toLongOrNull() ?: 0
                val event = params["event"]
                
                val infoHashHex = bytesToHex(infoHash.toByteArray(StandardCharsets.ISO_8859_1))
                
                // Get or create torrent info
                val torrentInfo = torrents.getOrPut(infoHashHex) {
                    TorrentTrackerInfo(infoHashHex)
                }
                
                // Handle events
                when (event) {
                    "stopped" -> {
                        torrentInfo.peers.removeIf { it.peerId == peerId }
                        log.debug("Peer $peerId stopped for torrent $infoHashHex")
                    }
                    "completed" -> {
                        log.debug("Peer $peerId completed torrent $infoHashHex")
                    }
                    else -> {
                        // Add or update peer
                        torrentInfo.peers.removeIf { it.peerId == peerId }
                        torrentInfo.peers.add(
                            PeerInfo(
                                peerId = peerId,
                                ip = ip,
                                port = port,
                                uploaded = uploaded,
                                downloaded = downloaded,
                                left = left
                            )
                        )
                        log.debug("Peer $peerId announced for torrent $infoHashHex")
                    }
                }
                
                // Send tracker response
                sendTrackerResponse(exchange, torrentInfo)
                
            } catch (e: Exception) {
                log.error("Error handling announce request", e)
                sendErrorResponse(exchange, "Internal server error")
            }
        }
        
        server.createContext("/scrape") { exchange ->
            try {
                val query = exchange.requestURI.query ?: ""
                val params = parseQueryString(query)
                val infoHashes = params.filterKeys { it == "info_hash" }.values
                
                val scrapeData = buildMap {
                    for (infoHashRaw in infoHashes) {
                        val infoHashHex = bytesToHex(infoHashRaw.toByteArray(StandardCharsets.ISO_8859_1))
                        val torrentInfo = torrents[infoHashHex]
                        if (torrentInfo != null) {
                            val complete = torrentInfo.peers.count { it.left == 0L }
                            val incomplete = torrentInfo.peers.count { it.left > 0 }
                            put(infoHashHex, mapOf(
                                "complete" to complete,
                                "incomplete" to incomplete,
                                "downloaded" to 0 // We don't track this
                            ))
                        }
                    }
                }
                
                sendScrapeResponse(exchange, scrapeData)
                
            } catch (e: Exception) {
                log.error("Error handling scrape request", e)
                sendErrorResponse(exchange, "Internal server error")
            }
        }
        
        server.start()
        log.info("Tracker server started on port $port")
    }
    
    fun stop() {
        if (::server.isInitialized) {
            server.stop(0)
            log.info("Tracker server stopped")
        }
        if (::executor.isInitialized) {
            executor.shutdown()
        }
    }
    
    fun addTorrent(torrentFile: Path) {
        try {
            val ti = TorrentInfo(torrentFile.toFile())
            val infoHashHex = ti.infoHash().toString()
            torrents.putIfAbsent(infoHashHex, TorrentTrackerInfo(infoHashHex))
            log.debug("Added torrent to tracker: $infoHashHex")
        } catch (e: Exception) {
            log.error("Failed to add torrent to tracker: ${torrentFile.fileName}", e)
        }
    }
    
    private fun parseQueryString(query: String): Map<String, String> {
        return query.split("&").mapNotNull {
            val parts = it.split("=", limit = 2)
            if (parts.size == 2) {
                val key = URLDecoder.decode(parts[0], StandardCharsets.UTF_8)
                val value = URLDecoder.decode(parts[1], StandardCharsets.UTF_8)
                key to value
            } else null
        }.toMap()
    }
    
    private fun sendTrackerResponse(exchange: com.sun.net.httpserver.HttpExchange, torrentInfo: TorrentTrackerInfo) {
        val peers = torrentInfo.peers.take(50) // Limit to 50 peers
        val peerList = peers.map { peer ->
            mapOf(
                "peer id" to peer.peerId,
                "ip" to peer.ip,
                "port" to peer.port
            )
        }
        
        val response = mapOf(
            "interval" to 1800, // 30 minutes
            "min interval" to 900, // 15 minutes
            "complete" to torrentInfo.peers.count { it.left == 0L },
            "incomplete" to torrentInfo.peers.count { it.left > 0 },
            "peers" to peerList
        )
        
        val bencoded = bencode(response)
        sendResponse(exchange, 200, bencoded)
    }
    
    private fun sendScrapeResponse(exchange: com.sun.net.httpserver.HttpExchange, scrapeData: Map<String, Map<String, Int>>) {
        val response = mapOf("files" to scrapeData)
        val bencoded = bencode(response)
        sendResponse(exchange, 200, bencoded)
    }
    
    private fun sendErrorResponse(exchange: com.sun.net.httpserver.HttpExchange, message: String) {
        val response = mapOf("failure reason" to message)
        val bencoded = bencode(response)
        sendResponse(exchange, 200, bencoded) // Tracker errors are still HTTP 200
    }
    
    private fun sendResponse(exchange: com.sun.net.httpserver.HttpExchange, statusCode: Int, data: ByteArray) {
        exchange.sendResponseHeaders(statusCode, data.size.toLong())
        val os: OutputStream = exchange.responseBody
        os.write(data)
        os.close()
    }
    
    private fun bencode(value: Any?): ByteArray {
        return when (value) {
            is String -> {
                val bytes = value.toByteArray(StandardCharsets.ISO_8859_1)
                "${bytes.size}:".toByteArray(StandardCharsets.ISO_8859_1) + bytes
            }
            is Int -> "i${value}e".toByteArray(StandardCharsets.ISO_8859_1)
            is Long -> "i${value}e".toByteArray(StandardCharsets.ISO_8859_1)
            is List<*> -> {
                val result = StringBuilder("l")
                value.forEach { result.append(String(bencode(it), StandardCharsets.ISO_8859_1)) }
                result.append("e")
                result.toString().toByteArray(StandardCharsets.ISO_8859_1)
            }
            is Map<*, *> -> {
                val result = StringBuilder("d")
                value.entries.sortedBy { it.key.toString() }.forEach { (k, v) ->
                    result.append(String(bencode(k.toString()), StandardCharsets.ISO_8859_1))
                    result.append(String(bencode(v), StandardCharsets.ISO_8859_1))
                }
                result.append("e")
                result.toString().toByteArray(StandardCharsets.ISO_8859_1)
            }
            else -> throw IllegalArgumentException("Unsupported type for bencoding: ${value?.javaClass}")
        }
    }
    
    private fun bytesToHex(bytes: ByteArray): String {
        return bytes.joinToString("") { "%02x".format(it) }
    }
}
